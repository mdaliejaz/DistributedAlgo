from collections import deque
import sys
import da
import uuid
import worker
from util import Request
import time
import queue


class Coordinator(process):
    def setup(coordinators, dbInstance, config):
        self.tentativeSubjectCache = {}
        self.mainSubjectCache = {}
        self.resourceCache = {}
        self.requestQueue = {}
        self.responseQueue = {}
        self.coordinators = coordinators
        # Change to n workers and decide later
        self.workers = new(worker.Worker,
                           num=int(config.get("setup", "nworkerspercoord")))
        setup(self.workers, (self.coordinators, dbInstance, config,))
        start(self.workers)

    # resource coordinator instance
    # receive from subject coordinator
    # send to worker
    def receive(msg=('RESOURCE_COORDINATOR', request)):
        # update request with resourceAttributeMap
        if request.resourceID in resourceCache:
            request.resourceAttributeMap = resourceCache[request.resourceID]
        else:
            request.resourceAttributeMap = {}
        # send request to worker
        output('hello from resource coordinator resource: subjectID='
               + str(request.subjectID) + ', resourceID=' + str(
            request.resourceID))
        send(('WORKER_ASSIGN', request), to=workers)

    # subject coordinator instance, checks subject attribute conflicts
    # receive from worker
    # send to resource coordinator (for resource conflicts)
    def receive(msg=('WORKER_RESPONSE', response)):
        requestID = response.dbresponse.request.requestID
        subjectID = response.dbresponse.request.subjectID
        resourceID = response.dbresponse.request.resourceID
        
        output('WORKER_RESPONSE, subjectID=' + str(subjectID) +
               ', resource=' + str(resourceID))
        
        if requestID != requestQueue[subjectID][0]:
            responseQueue[requestID] = response
            return
        
        checkConflicts(response)
 
    def checkConflicts(response):
        requestID = response.dbresponse.request.requestID
        subjectID = response.dbresponse.request.subjectID
        
        # send result if evaluation is false
        if not response.dbresponse.evaluation:
            requestQueue[subjectID].popleft()
            output('sending response to client - failure')
            send(('RESULT_CLIENT', 'false'),
                 to=response.dbresponse.request.fromClient)
            if requestQueue[subjectID] and (requestQueue[subjectID][0] in responseQueue):
                resp = responseQueue[requestQueue[subjectID][0]]
                del responseQueue[requestQueue[subjectID][0]]
                checkConflicts(resp)
            return
        
        # check for conflict
        conflictHappened = False
        for key, _ in response.dbresponse.readDbSubjectMap.items():
            if key in tentativeSubjectCache or key in mainSubjectCache:
                conflictHappened = True

        for key, value in response.readSubjectAttributeMap.items():
            if key in mainSubjectCache:
                if value[1] != mainSubjectCache[key][1]:
                    conflictHappened = True

        if conflictHappened:
            # conflict happened, restart
            output('subject attr conflict happened')
            self.tentativeSubjectCache[subjectID] = {}
            requestQueue[subjectID].popleft()
            id = int(subjectID) % len(coordinators)
            # from_ is getting fuckeed here. It must come from client
            send(('CLIENT', subjectID,
                  response.dbresponse.request.resourceID,
                  response.dbresponse.request.action,
                  response.dbresponse.request.fromClient),
                 to=coordinators[id])
            if  requestQueue[subjectID] and (requestQueue[subjectID][0] in responseQueue):
                resp = responseQueue[requestQueue[subjectID][0]]
                del responseQueue[requestQueue[subjectID][0]]
                checkConflicts(resp)
            return

        # no conflicts
        # tentatively update subject attributes
        if not subjectID in tentativeSubjectCache:
            tentativeSubjectCache[subjectID] = {}
        timestamp = int(time.time())
        for key, value in response.toUpdateSubjectMap.items():
            tentativeSubjectCache[subjectID][key] = (value, timestamp)
        output('sending to coordinator ' + str(
            response.dbresponse.request.resourceID))
        # send to resource coordinator to check for resource attribute conflict
        id = int(response.dbresponse.request.resourceID) % len(coordinators)
        send(('RESOURCE_COORDINATOR_CONFLICT_CHECK', response),
             to=coordinators[id])
                
    # resource coordinator instance, checks resource attribute conflicts
    # receive from subject coordinator
    # send to subject coordinator
    def receive(msg=('RESOURCE_COORDINATOR_CONFLICT_CHECK', response)):
        output('in response coordinator conflict check')
        # check for conflict
        conflictHappened = False
        if not response.dbresponse.request.resourceID in resourceCache:
            resourceCache[response.dbresponse.request.resourceID] = {}
        for key, _ in response.dbresponse.readDbResourceMap.items():
            if key in resourceCache[response.dbresponse.request.resourceID]:
                conflictHappened = True

        for key, value in response.readResourceAttributeMap.items():
            if key in resourceCache[response.dbresponse.request.resourceID]:
                if value[1] != resourceCache[response.dbresponse.request.resourceID][key][1]:
                    conflictHappened = True

        if conflictHappened:
            # conflict happened, restart
            output('resource attr conflict happened')

        if not conflictHappened:
            if not response.dbresponse.request.resourceID in resourceCache:
                resourceCache[response.dbresponse.request.resourceID] = {}
            timestamp = int(time.time())
            for key, value in response.toUpdateResourceMap.items():
                resourceCache[response.dbresponse.request.resourceID][key] = (
                    value, timestamp)

        id = int(response.dbresponse.request.subjectID) % len(coordinators)
        send(('RESOURCE_COORDINATOR_CONFLICT_CHECK_RESPONSE',
              (response, conflictHappened)), to=coordinators[id])

    # subject coordinator instance
    # receive from resource coordinator
    # send to client, if no conflict happened
    def receive(msg=('RESOURCE_COORDINATOR_CONFLICT_CHECK_RESPONSE',
                     (response, conflictHappened))):
        requestID = response.dbresponse.request.requestID
        subjectID = response.dbresponse.request.subjectID
        
        if conflictHappened:
            id = int(response.dbresponse.request.subjectID) % len(coordinators)
            tentativeSubjectCache[response.dbresponse.request.subjectID] = {}
            requestQueue[response.dbresponse.request.subjectID].popleft()
            output('restarting request')
            # Getting fucked
            send(('CLIENT', response.dbresponse.request.subjectID,
                  response.dbresponse.request.resourceID,
                  response.dbresponse.request.action,
                  response.dbresponse.request.fromClient), to=coordinators[id])
        else:
            if not response.dbresponse.request.subjectID in mainSubjectCache:
                mainSubjectCache[response.dbresponse.request.subjectID] = {}
            for key, val in tentativeSubjectCache[
                response.dbresponse.request.subjectID].items():
                mainSubjectCache[response.dbresponse.request.subjectID][
                    key] = val
            self.tentativeSubjectCache = {}
            requestQueue[response.dbresponse.request.subjectID].popleft()
            output('sending response to client - success', response.dbresponse.request.fromClient)
            send(('RESULT_CLIENT', 'success'),
                 to=response.dbresponse.request.fromClient)
 
        if  requestQueue[subjectID] and (requestQueue[subjectID][0] in responseQueue):
            resp = responseQueue[requestQueue[subjectID][0]]
            del responseQueue[requestQueue[subjectID][0]]
            checkConflicts(resp)  
                     
    # subject coordinator instance
    # receive from client
    # send to resource coordinator
    def receive(msg=('CLIENT', subjectID, resourceID, action, clientPReq),
                from_=clientP):
        output(
            'client hello subjectID=' + str(subjectID) + ', resourceID=' + str(
                resourceID))
        if clientPReq is not None:
            clientP = clientPReq
            
        output("FROM CLIENT =", clientP)
        # generate unique request ID and put in queue (lock?)
        requestID = uuid.uuid4()
        if not subjectID in requestQueue:
            requestQueue[subjectID] = deque()
        requestQueue[subjectID].append(requestID)
        output("QUEUE", requestQueue[subjectID])
        # create a new map to pass down the request
        subjectAttributeMap = {}
        if subjectID in tentativeSubjectCache:
            for key, val in tentativeSubjectCache[subjectID].items():
                subjectAttributeMap[key] = val
        if subjectID in mainSubjectCache:
            for key, val in mainSubjectCache[subjectID].items():
                if not key in subjectAttributeMap:
                    subjectAttributeMap[key] = val

        # frame request and forward to Resource coordinator
        request = Request(requestID, clientP, subjectID, resourceID,
                          action, subjectAttributeMap, None)
        id = int(resourceID) % len(coordinators)
        send(('RESOURCE_COORDINATOR', request), to=(coordinators[id]))

    def run():
        output('coordinator starting...')
        await(received(('done',)))
