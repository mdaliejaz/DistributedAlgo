from collections import deque
import sys
import da
import uuid
import worker
from util import Request
import time
import queue


class Coordinator(process):
    def setup(coordinators, dbInstance, config):
        self.tentativeSubjectCache = {}
        self.mainSubjectCache = {}
        self.resourceCache = {}
        self.requestQueue = {}
        self.coordinators = coordinators
        # Change to n workers and decide later
        self.workers = new(worker.Worker, num=int(config.get("setup", "nworkerspercoord")))
        setup(self.workers, (self.coordinators, dbInstance, config,))
        start(self.workers)

    # resource coordinator instance
    # receive from subject coordinator
    # send to worker
    def receive(msg=('RESOURCE_COORDINATOR', request)):
        # update request with resourceAttributeMap
        if request.requestID in resourceCache:
            request.resourceAttributeMap = resourceCache[request.resourceID]
        else:
            request.resourceAttributeMap = {}
        # send request to worker
        output('hello from resource coordinator resource: subjectID=' + str(request.subjectID) + ', resourceID=' + str(
            request.resourceID))
        send(('WORKER_ASSIGN', request), to=workers)

    # subject coordinator instance, checks subject attribute conflicts
    # receive from worker
    # send to resource coordinator (for resource conflicts)
    def receive(msg=('WORKER_RESPONSE', response)):
        output('WORKER_RESPONSE, subjectID=' +
               str(response.dbresponse.request.subjectID) +
               ', resource=' + str(response.dbresponse.request.resourceID))
        subjectID = response.dbresponse.request.subjectID
        # send result if evaluation is false
        if not response.dbresponse.evaluation:
            requestQueue[subjectID].popleft()
            output('evaluation is False')
            send(('RESULT_CLIENT', 'false'), to=response.dbresponse.request.fromClient)
            return
        # wait for first element to be processed if this is not the first
        while requestQueue[subjectID][0] != response.dbresponse.request.requestID:
            output('infinite wait')
            pass # Put all responses in another queue dont queue r1
        # check for conflict
        conflictHappened = False
        for key, _ in response.dbresponse.dbSubjectMap.items():
            if key in tentativeSubjectCache or key in mainSubjectCache:
                conflictHappened = True

        for key, value in response.dbresponse.request.subjectAttributeMap.items(): # Atanu needs to send new map
            if key in mainSubjectCache:
                if value[1] != mainSubjectCache[key][1]:
                    conflictHappened = True
            
        if conflictHappened:
            # conflict happened, restart
            output('subject attr conflict happened')
            self.tentativeSubjectCache[subjectID] = {} # Ok sync with SP and check
            requestQueue[subjectID].popleft()
            id = int(subjectID) % len(coordinators)
            send(('CLIENT', subjectID,
                  response.dbresponse.request.resourceID,
                  response.dbresponse.request.action),
                 to=coordinators[id])
            return
        
        # no conflicts
        # tentatively update subject attributes
        if not subjectID in tentativeSubjectCache:
            tentativeSubjectCache[subjectID] = {}
        timestamp = int(time.time())
        for key, value in response.toUpdateSubjectMap.items():
            tentativeSubjectCache[subjectID][key] = (value, timestamp)
        output('sending to coordinator ' + str(response.dbresponse.request.resourceID))
        # send to resource coordinator to check for resource attribute conflict
        id = int(response.dbresponse.request.resourceID) % len(coordinators)
        send(('RESOURCE_COORDINATOR_CONFLICT_CHECK', response), to=coordinators[id])

    # resource coordinator instance, checks resource attribute conflicts
    # receive from subject coordinator
    # send to subject coordinator
    def receive(msg=('RESOURCE_COORDINATOR_CONFLICT_CHECK', response)):
        output('in response coordinator conflict check')
        # check for conflict
        conflictHappened = False
        for key, _ in response.dbresponse.dbResourceMap.items():
            if key in resourceCache:
                conflictHappened = True

        for key, value in response.dbresponse.request.resourceAttributeMap.items():
            if key in resourceCache:
                if value[1] != resourceCache[key][1]:
                    conflictHappened = True
                    
        if conflictHappened:
            # conflict happened, restart
            output('resource attr conflict happened')
            
        if not conflictHappened:
            if not response.dbresponse.request.resourceID in resourceCache:
                resourceCache[response.dbresponse.request.resourceID] = {}
            timestamp = int(time.time())
            for key, value in response.toUpdateResourceMap.items():
                resourceCache[response.dbresponse.request.resourceID][key] = (value, timestamp)
        id = int(response.dbresponse.request.subjectID) % len(coordinators)
        send(('RESOURCE_COORDINATOR_CONFLICT_CHECK_RESPONSE', (response, conflictHappened)), to=coordinators[id])

    # subject coordinator instance
    # receive from resource coordinator
    # send to client, if no conflict happened
    def receive(msg=('RESOURCE_COORDINATOR_CONFLICT_CHECK_RESPONSE', (response, conflictHappened))):
        if conflictHappened:
            id = int(response.dbresponse.request.subjectID) % len(coordinators)
            tentativeSubjectCache[response.dbresponse.request.subjectID] = {}
            requestQueue[response.dbresponse.request.subjectID].popleft()
            output('restarting request')
            send(('CLIENT', response.dbresponse.request.subjectID,
                  response.dbresponse.request.resourceID,
                  response.dbresponse.request.action),
                 to=coordinators[id])
        else:
            if not response.dbresponse.request.subjectID in mainSubjectCache:
                mainSubjectCache[response.dbresponse.request.subjectID] = {}
            for key, val in tentativeSubjectCache[response.dbresponse.request.subjectID].items():
                mainSubjectCache[response.dbresponse.request.subjectID][key] = val
            requestQueue[response.dbresponse.request.subjectID].popleft()
            output('sending response to client')
            send(('RESULT_CLIENT', 'success'), to=response.dbresponse.request.fromClient)

    # subject coordinator instance
    # receive from client
    # send to resource coordinator
    def receive(msg=('CLIENT', subjectID, resourceID, action), from_=clientProcess):
        output('client hello subjectID=' + str(subjectID) + ', resourceID=' + str(resourceID))
        # generate unique request ID and put in queue (lock?)
        requestID = uuid.uuid4()
        if not subjectID in requestQueue:
            requestQueue[subjectID] = deque()
        requestQueue[subjectID].append(requestID)
        print("QUEUE", requestQueue[subjectID])
        # create a new map to pass down the request
        subjectAttributeMap = {}
        if subjectID in tentativeSubjectCache:
            for key, val in tentativeSubjectCache[subjectID].items():
                subjectAttributeMap[key] = val
        if subjectID in mainSubjectCache:
            for key, val in mainSubjectCache[subjectID].items():
                if not key in subjectAttributeMap:
                    subjectAttributeMap[key] = val

        # frame request and forward to Resource coordinator
        request = Request(requestID,
                          clientProcess,
                          subjectID,
                          resourceID,
                          action,
                          subjectAttributeMap,
                          None)
        id = int(resourceID) % len(coordinators)
        send(('RESOURCE_COORDINATOR', request), to=(coordinators[id]))

    def run():
        output('coordinator starting...')
        await(received(('done',)))
