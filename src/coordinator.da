import sys
import da
import uuid
import worker
import time
import queue
from util import Request
from collections import deque

class Coordinator(process):
    def setup(coordinators, dbInstance, config):
        self.tentativeSubjectCache = {}
        self.mainSubjectCache = {}
        self.resourceCache = {}
        self.requestQueue = {}
        self.responseQueue = {}
        self.coordinators = coordinators
        # Change to n workers and decide later
        self.workers = new(worker.Worker,
                           num=int(config.get("setup", "nworkerspercoord")))
        setup(self.workers, (self.coordinators, dbInstance, config,))
        start(self.workers)

    # resource coordinator instance
    # receive from subject coordinator
    # send to worker
    def receive(msg=('RESOURCE_COORDINATOR', request)):
        # update request with resourceAttributeMap
        if request.resourceID in resourceCache:
            request.resourceAttributeMap = resourceCache[request.resourceID]
        else:
            request.resourceAttributeMap = {}
        # send request to worker
        output('resource coordinator received: subjectID = ',
               request.subjectID, ', resourceID = ', request.resourceID)
        send(('WORKER_ASSIGN', request), to=workers)

    # subject coordinator instance, checks subject attribute conflicts
    # receive from worker
    # send to resource coordinator (for resource conflicts)
    def receive(msg=('WORKER_RESPONSE', response)):
        requestID = response.dbresponse.request.requestID
        subjectID = response.dbresponse.request.subjectID
        resourceID = response.dbresponse.request.resourceID
        
        output('WORKER_RESPONSE, subjectID=' + str(subjectID) +
               ', resource=' + str(resourceID))
        
        if requestID != requestQueue[subjectID][0]:
            responseQueue[requestID] = response
            return
        
        checkConflicts(response)
 
    def checkResponseQueue(subjectID):
        if  requestQueue[subjectID] and (requestQueue[subjectID][0] in responseQueue):
            resp = responseQueue[requestQueue[subjectID][0]]
            del responseQueue[requestQueue[subjectID][0]]
            checkConflicts(resp)
        return
    
    def checkConflicts(response):
        requestID = response.dbresponse.request.requestID
        subjectID = response.dbresponse.request.subjectID
        fromClient = response.dbresponse.request.fromClient
        resourceID = response.dbresponse.request.resourceID
        
        # send result if evaluation is false
        if not response.dbresponse.evaluation:
            requestQueue[subjectID].popleft()
            output('sending response to client - failure')
            send(('RESULT_CLIENT', 'false'), to=fromClient)
            checkResponseQueue(subjectID)
            return
        
        # check for conflict
        conflictHappened = False
        for key, _ in response.dbresponse.readDbSubjectMap.items():
            if key in tentativeSubjectCache or key in mainSubjectCache:
                conflictHappened = True

        for key, value in response.readSubjectAttributeMap.items():
            if key in mainSubjectCache:
                if value[1] != mainSubjectCache[key][1]:
                    conflictHappened = True

        if conflictHappened:
            # conflict happened, restart
            output('subject attr conflict happened')
            self.tentativeSubjectCache[subjectID] = {}
            requestQueue[subjectID].popleft()
            id = int(subjectID) % len(coordinators)
            send(('CLIENT', subjectID, resourceID,
                  response.dbresponse.request.action,
                  fromClient),to=coordinators[id])
            checkResponseQueue(subjectID)
            return

        # no conflicts
        # tentatively update subject attributes
        if not subjectID in tentativeSubjectCache:
            tentativeSubjectCache[subjectID] = {}
        for key, value in response.toUpdateSubjectMap.items():
            timestamp = int(time.time() * 1000000)
            tentativeSubjectCache[subjectID][key] = (value, timestamp)
        output('sending to coordinator ', resourceID)
        # send to resource coordinator to check for resource attribute conflict
        id = int(response.dbresponse.request.resourceID) % len(coordinators)
        send(('RESOURCE_COORDINATOR_CONFLICT_CHECK', response),
             to=coordinators[id])
                
    # resource coordinator instance, checks resource attribute conflicts
    # receive from subject coordinator
    # send to subject coordinator
    def receive(msg=('RESOURCE_COORDINATOR_CONFLICT_CHECK', response)):
        output('in response coordinator conflict check')
        # check for conflict
        conflictHappened = False
        resourceID = response.dbresponse.request.resourceID
        
        if not resourceID in resourceCache:
            resourceCache[resourceID] = {}
        for key, _ in response.dbresponse.readDbResourceMap.items():
            if key in resourceCache[resourceID]:
                conflictHappened = True

        for key, value in response.readResourceAttributeMap.items():
            if key in resourceCache[resourceID]:
                if value[1] != resourceCache[resourceID][key][1]:
                    conflictHappened = True

        if conflictHappened:
            # conflict happened, restart
            output('resource attr conflict happened')

        if not conflictHappened:
            if not resourceID in resourceCache:
                resourceCache[resourceID] = {}
            for key, value in response.toUpdateResourceMap.items():
                timestamp = int(time.time() * 1000000)
                resourceCache[resourceID][key] = (value, timestamp)

        id = int(response.dbresponse.request.subjectID) % len(coordinators)
        send(('RESOURCE_COORDINATOR_CONFLICT_CHECK_RESPONSE',
              (response, conflictHappened)), to=coordinators[id])

    # subject coordinator instance
    # receive from resource coordinator
    # send to client, if no conflict happened
    def receive(msg=('RESOURCE_COORDINATOR_CONFLICT_CHECK_RESPONSE',
                     (response, conflictHappened))):
        subjectID = response.dbresponse.request.subjectID
        
        if conflictHappened:
            id = int(subjectID) % len(coordinators)
            tentativeSubjectCache[subjectID] = {}
            requestQueue[subjectID].popleft()
            send(('CLIENT', subjectID,
                  response.dbresponse.request.resourceID,
                  response.dbresponse.request.action,
                  response.dbresponse.request.fromClient), to=coordinators[id])
        else:
            if not subjectID in mainSubjectCache:
                mainSubjectCache[subjectID] = {}
            for key, val in tentativeSubjectCache[subjectID].items():
                mainSubjectCache[subjectID][key] = val
            self.tentativeSubjectCache = {}
            requestQueue[subjectID].popleft()
            output('sending response to client - success')
            send(('RESULT_CLIENT', 'success'),
                 to=response.dbresponse.request.fromClient)
 
        checkResponseQueue(subjectID) 
                     
    # subject coordinator instance
    # receive from client
    # send to resource coordinator
    def receive(msg=('CLIENT', subjectID, resourceID, action, clientRestartReq),
                from_=clientReq):
        output(
            'client message received subjectID=' + str(subjectID)
            + ', resourceID=' + str(resourceID))
        
        if clientRestartReq is not None:
            clientReq = clientRestartReq
            
        # generate unique request ID and put in queue (lock?)
        requestID = uuid.uuid4()
        if not subjectID in requestQueue:
            requestQueue[subjectID] = deque()
        requestQueue[subjectID].append(requestID)
        # create a new map to pass down the request
        subjectAttributeMap = {}
        if subjectID in tentativeSubjectCache:
            for key, val in tentativeSubjectCache[subjectID].items():
                subjectAttributeMap[key] = val
        if subjectID in mainSubjectCache:
            for key, val in mainSubjectCache[subjectID].items():
                if not key in subjectAttributeMap:
                    subjectAttributeMap[key] = val

        # frame request and forward to Resource coordinator
        request = Request(requestID, clientReq, subjectID, resourceID,
                          action, subjectAttributeMap, None)
        id = int(resourceID) % len(coordinators)
        send(('RESOURCE_COORDINATOR', request), to=(coordinators[id]))

    def run():
        output('coordinator starting...')
        await(received(('done',)))
